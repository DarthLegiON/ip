{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"./","text":"Introduction IP is an immutable value object for (both version 4 and 6) IP addresses. Several helper methods are provided for ranges, broadcast and network addresses, subnet masks, whether an IP is a certain type (defined by RFC's), etc. Internally, the library converts IP addresses to a binary sequence for easy mathematical operations and consistency. You can choose to work with IPv6 addresses as 16-byte binary sequences, IPv4 addresses as 4-byte binary sequences, or work with both interchangeably by representing IPv4 addresses as 16-byte binary sequences (which is recommended for most applications). License Please see the separate license file included in this repository for a full copy of the MIT license, which this project is licensed under. Authors Zan Baldwin Jaume Casado Ruiz Pascal Hofmann If you make a contribution (submit a pull request), don't forget to add your name here!","title":"Introduction"},{"location":"./#introduction","text":"IP is an immutable value object for (both version 4 and 6) IP addresses. Several helper methods are provided for ranges, broadcast and network addresses, subnet masks, whether an IP is a certain type (defined by RFC's), etc. Internally, the library converts IP addresses to a binary sequence for easy mathematical operations and consistency. You can choose to work with IPv6 addresses as 16-byte binary sequences, IPv4 addresses as 4-byte binary sequences, or work with both interchangeably by representing IPv4 addresses as 16-byte binary sequences (which is recommended for most applications).","title":"Introduction"},{"location":"./#license","text":"Please see the separate license file included in this repository for a full copy of the MIT license, which this project is licensed under.","title":"License"},{"location":"./#authors","text":"Zan Baldwin Jaume Casado Ruiz Pascal Hofmann If you make a contribution (submit a pull request), don't forget to add your name here!","title":"Authors"},{"location":"02-installation.html","text":"Installation System Requirements This library will not support end-of-life PHP versions, therefore only PHP 5.6+ is supported. You can expect support for 7.0+ only commencing 1st January 2019. This library cannot be used on 32-bits systems due to a dependency on the in-built PHP functions inet_pton and inet_ntop . This dependency may be circumvented in a future version but is not guaranteed. Install The library is available on Packagist and should be installed using Composer . This can be done by running the following command on a composer installed box: $ composer require darsyn/ip Most modern frameworks will include Composer out of the box, but ensure the following file is included: <?php declare(strict_types=1); require __DIR__ . '/vendor/autoload.php';","title":"Installation"},{"location":"02-installation.html#installation","text":"","title":"Installation"},{"location":"02-installation.html#system-requirements","text":"This library will not support end-of-life PHP versions, therefore only PHP 5.6+ is supported. You can expect support for 7.0+ only commencing 1st January 2019. This library cannot be used on 32-bits systems due to a dependency on the in-built PHP functions inet_pton and inet_ntop . This dependency may be circumvented in a future version but is not guaranteed.","title":"System Requirements"},{"location":"02-installation.html#install","text":"The library is available on Packagist and should be installed using Composer . This can be done by running the following command on a composer installed box: $ composer require darsyn/ip Most modern frameworks will include Composer out of the box, but ensure the following file is included: <?php declare(strict_types=1); require __DIR__ . '/vendor/autoload.php';","title":"Install"},{"location":"03-overview.html","text":"Overview IP addresses get automatically validated on object instantiation; if the IP address supplied is invalid, an InvalidIpAddressException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4; use Darsyn\\IP\\Exception; try { $ip = IPv4::factory('127.0.0.1'); } catch (Exception\\InvalidIpAddressException $e) { echo 'The IP address supplied is invalid!'; } Versions This library can work with version 4 addresses, version 6 addresses, or both formats interchangeably using the classes IPv4 , IPv6 and Multi respectively. All versions implement IpInterface , along with extra interfaces for each version: - IPv4 implements Version4Interface , - IPv6 implements Version6Interface , - Multi implements MultiVersionInterface (which in turn implements both Version4Interface and Version6Interface ). If you try to use an version 6 address with the IPv4 class, or an version 4 address with the IPv6 class, then a WrongVersionException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4; use Darsyn\\IP\\Exception; try { $ip = IPv4::factory('::1'); } catch (Exception\\WrongVersionException $e) { echo 'Only version 4 IP addresses are allowed!'; } catch (Exception\\InvalidIpAddressException $e) { echo 'The IP address supplied is invalid!'; } Note: The WrongVersionException is provided to give finer control on handling errors. It extends InvalidIpAddressException so catching it isn't necessary. Each class has methods for determining the version: $ip->getVersion() returns the IP address version (either int(4) or int(6) ). $ip->isVersion($version) returns a boolean value on whether the $ip object is the version specified in $version (which must be either int(4) or int(6) ). $ip->isVersion4() returns a boolean value on whether the $ip object contains a version 4 address. $ip->isVersion6() returns a boolean value on whether the $ip object contains a version 6 address. Note: When using the Multi class, the address version is determined by what embedding strategy is used rather than what notation was passed to the constructor. Return Formats Once an IP object has been initialised, the IP address value can be returned in either human-readable format or in binary. This binary string will always be 4 bytes long when using IPv4 and 16 bytes long when using IPv6 and Multi . Human-readable format comes in 3 flavours: - Dot notation is for IPv4 addresses, eg 127.0.0.1 . - Compacted is for IPv6 addresses, eg 2001:db8::a60:8a2e:370:7334 . - Expanded is for IPv6 addresses, eg 2001:0db8:0000:0000:0a60:8a2e:0370:7334 . getDotAddress() Is only available for IPv4 and Multi classes. Calling getDotAddress() on an instance of Multi that contains a version 6 address will result in a WrongVersionException being thrown. <?php use Darsyn\\IP\\Version\\Multi as IP; use Darsyn\\IP\\Exception; $ip = IP::factory('127.0.0.1'); try { echo $ip->getDotAddress(); // string(\"127.0.0.1\") } catch (Exception\\WrongVersionException $e) { echo 'Cannot convert a version 6 address to dot-notation!'; } getCompactedAddress() Is only available for IPv6 and Multi classes. Calling getCompactedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); echo $ip->getCompactedAddress(); // string(\"::ffff:7f00:1\") getExpandedAddress() Is only available for IPv6 and Multi classes. Calling getExpandedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->getExpandedAddress(); // string(\"0000:0000:0000:0000:0000:ffff:7f00:0001\") getProtocolAppropriateAddress() Is only available for the Multi class. If the instance of Multi contains a version 4 address, it will be returned in dot-notation, otherwise it returns a compacted version 6 address. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::ffff:7f00:1'); $ip->getProtocolAppropriateAddress(); // string(\"127.0.0.1\") getBinary() Returns the 16 byte (4 bytes if using IPv4 ) binary string of the IP address. This will most likely contain non-printable characters, so is not appropriate for displaying. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $binary = $ip->getBinary(); String Casting Casting the IP object to a string is the equivalent of calling getBinary() . Whilst this may not be the most useful when dumping the object, it's the only method that consistently available is all classes. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $binary = (string) $ip;","title":"Overview"},{"location":"03-overview.html#overview","text":"IP addresses get automatically validated on object instantiation; if the IP address supplied is invalid, an InvalidIpAddressException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4; use Darsyn\\IP\\Exception; try { $ip = IPv4::factory('127.0.0.1'); } catch (Exception\\InvalidIpAddressException $e) { echo 'The IP address supplied is invalid!'; }","title":"Overview"},{"location":"03-overview.html#versions","text":"This library can work with version 4 addresses, version 6 addresses, or both formats interchangeably using the classes IPv4 , IPv6 and Multi respectively. All versions implement IpInterface , along with extra interfaces for each version: - IPv4 implements Version4Interface , - IPv6 implements Version6Interface , - Multi implements MultiVersionInterface (which in turn implements both Version4Interface and Version6Interface ). If you try to use an version 6 address with the IPv4 class, or an version 4 address with the IPv6 class, then a WrongVersionException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4; use Darsyn\\IP\\Exception; try { $ip = IPv4::factory('::1'); } catch (Exception\\WrongVersionException $e) { echo 'Only version 4 IP addresses are allowed!'; } catch (Exception\\InvalidIpAddressException $e) { echo 'The IP address supplied is invalid!'; } Note: The WrongVersionException is provided to give finer control on handling errors. It extends InvalidIpAddressException so catching it isn't necessary. Each class has methods for determining the version: $ip->getVersion() returns the IP address version (either int(4) or int(6) ). $ip->isVersion($version) returns a boolean value on whether the $ip object is the version specified in $version (which must be either int(4) or int(6) ). $ip->isVersion4() returns a boolean value on whether the $ip object contains a version 4 address. $ip->isVersion6() returns a boolean value on whether the $ip object contains a version 6 address. Note: When using the Multi class, the address version is determined by what embedding strategy is used rather than what notation was passed to the constructor.","title":"Versions"},{"location":"03-overview.html#return-formats","text":"Once an IP object has been initialised, the IP address value can be returned in either human-readable format or in binary. This binary string will always be 4 bytes long when using IPv4 and 16 bytes long when using IPv6 and Multi . Human-readable format comes in 3 flavours: - Dot notation is for IPv4 addresses, eg 127.0.0.1 . - Compacted is for IPv6 addresses, eg 2001:db8::a60:8a2e:370:7334 . - Expanded is for IPv6 addresses, eg 2001:0db8:0000:0000:0a60:8a2e:0370:7334 .","title":"Return Formats"},{"location":"03-overview.html#getdotaddress","text":"Is only available for IPv4 and Multi classes. Calling getDotAddress() on an instance of Multi that contains a version 6 address will result in a WrongVersionException being thrown. <?php use Darsyn\\IP\\Version\\Multi as IP; use Darsyn\\IP\\Exception; $ip = IP::factory('127.0.0.1'); try { echo $ip->getDotAddress(); // string(\"127.0.0.1\") } catch (Exception\\WrongVersionException $e) { echo 'Cannot convert a version 6 address to dot-notation!'; }","title":"getDotAddress()"},{"location":"03-overview.html#getcompactedaddress","text":"Is only available for IPv6 and Multi classes. Calling getCompactedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); echo $ip->getCompactedAddress(); // string(\"::ffff:7f00:1\")","title":"getCompactedAddress()"},{"location":"03-overview.html#getexpandedaddress","text":"Is only available for IPv6 and Multi classes. Calling getExpandedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->getExpandedAddress(); // string(\"0000:0000:0000:0000:0000:ffff:7f00:0001\")","title":"getExpandedAddress()"},{"location":"03-overview.html#getprotocolappropriateaddress","text":"Is only available for the Multi class. If the instance of Multi contains a version 4 address, it will be returned in dot-notation, otherwise it returns a compacted version 6 address. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::ffff:7f00:1'); $ip->getProtocolAppropriateAddress(); // string(\"127.0.0.1\")","title":"getProtocolAppropriateAddress()"},{"location":"03-overview.html#getbinary","text":"Returns the 16 byte (4 bytes if using IPv4 ) binary string of the IP address. This will most likely contain non-printable characters, so is not appropriate for displaying. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $binary = $ip->getBinary();","title":"getBinary()"},{"location":"03-overview.html#string-casting","text":"Casting the IP object to a string is the equivalent of calling getBinary() . Whilst this may not be the most useful when dumping the object, it's the only method that consistently available is all classes. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $binary = (string) $ip;","title":"String Casting"},{"location":"04-helpers.html","text":"Helper Methods Helper methods are for working with IP address and CIDR subnet masks. Since IP objects are meant to be immutable, whenever an IP is returned it is returned as a new instance of IpInterface rather than modifying the existing object - they are also returned as a static instance meaning an IPv4 object would return a new IPv4 object, an IPv6 returns IPv6 , etc. CIDR (Subnet Mask) All the helper methods require a CIDR value. Anyone who has worked with CIDR notation before will most likely be used to a subnet mask between 0 and 32. However, since this library deals with both IPv4 and IPv6 the CIDR values can range up to 128. Instances of IPv4 will always deal with CIDR values between 0 and 32. Instances of IPv6 will always deal with CIDR values between 0 and 128. Instances of Multi will: - Detect if the IP address is a version 4 address (according to the embedding strategy). - If version 4 and the CIDR is less or equal to 32, attempt the method as if it was called from an IPv4 instance. - Otherwise (or the previous step resulted in an error/exception) attempt the method as if it was called from an IPv6 instance. <?php use Darsyn\\IP\\Version\\Multi as IP; // IP is version 4 address and CIDR is <= 32. Uses IPv4::getNetworkIp(). IP::factory('127.0.0.1')->getNetworkIp(26); // IP is version 4 address but CIDR is more than 32. Uses IPv6::getNetworkIp(). IP::factory('127.0.0.1')->getNetworkIp(107); // IP is version 6 address. Uses IPv6::getNetworkIp(). IP::factory('2001:db8::a60:8a2e:0:7334')->getNetworkIp(50); Methods that deal with CIDRs throw an InvalidCidrException when a CIDR value that is out of range is passed. Out of range values are any value that is: - Not an integer, - Below zero, - Above 32 (for IPv4 ), or - Above 128 (for IPv6 and Multi ). <?php use Darsyn\\IP\\Exception; use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); try { $network = $ip->getNetworkIp(129); } catch (Exception\\InvalidCidrException $e) { echo sprintf( '\"%d\" is not a valid CIDR value!', $e->getSuppliedCidr() ); } inRange() inRange(IpInterface $ip, int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP; $hostIp = IP::factory(':ffff:c22:384e'); $clientIp = IP::factory('12.48.183.1'); $clientIp->inRange($hostIp, 11); // bool(true) $clientIp->inRange($hostIp, 24); // bool(false) getNetworkIp() getNetworkIp(int $cidr): IpInterface <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('12.34.56.78'); // Get the network address of an IP address given a subnet mask. $networkIp = $ip->getNetworkIp(19); $networkIp->getProtocolAppropriateAddress(); // string(\"12.34.32.0\") $ip === $networkIp; // bool(false) getBroadcastIp() getBroadcastIp(int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('12.34.56.78'); // Get the broadcast address of an IP address given a subnet mask. $broadcastIp = $ip->getBroadcastIp(19); $broadcastIp->getProtocolAppropriateAddress(); // string(\"12.34.63.255\") $ip === $broadcastIp; // bool(false)","title":"Helpers"},{"location":"04-helpers.html#helper-methods","text":"Helper methods are for working with IP address and CIDR subnet masks. Since IP objects are meant to be immutable, whenever an IP is returned it is returned as a new instance of IpInterface rather than modifying the existing object - they are also returned as a static instance meaning an IPv4 object would return a new IPv4 object, an IPv6 returns IPv6 , etc.","title":"Helper Methods"},{"location":"04-helpers.html#cidr-subnet-mask","text":"All the helper methods require a CIDR value. Anyone who has worked with CIDR notation before will most likely be used to a subnet mask between 0 and 32. However, since this library deals with both IPv4 and IPv6 the CIDR values can range up to 128. Instances of IPv4 will always deal with CIDR values between 0 and 32. Instances of IPv6 will always deal with CIDR values between 0 and 128. Instances of Multi will: - Detect if the IP address is a version 4 address (according to the embedding strategy). - If version 4 and the CIDR is less or equal to 32, attempt the method as if it was called from an IPv4 instance. - Otherwise (or the previous step resulted in an error/exception) attempt the method as if it was called from an IPv6 instance. <?php use Darsyn\\IP\\Version\\Multi as IP; // IP is version 4 address and CIDR is <= 32. Uses IPv4::getNetworkIp(). IP::factory('127.0.0.1')->getNetworkIp(26); // IP is version 4 address but CIDR is more than 32. Uses IPv6::getNetworkIp(). IP::factory('127.0.0.1')->getNetworkIp(107); // IP is version 6 address. Uses IPv6::getNetworkIp(). IP::factory('2001:db8::a60:8a2e:0:7334')->getNetworkIp(50); Methods that deal with CIDRs throw an InvalidCidrException when a CIDR value that is out of range is passed. Out of range values are any value that is: - Not an integer, - Below zero, - Above 32 (for IPv4 ), or - Above 128 (for IPv6 and Multi ). <?php use Darsyn\\IP\\Exception; use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); try { $network = $ip->getNetworkIp(129); } catch (Exception\\InvalidCidrException $e) { echo sprintf( '\"%d\" is not a valid CIDR value!', $e->getSuppliedCidr() ); }","title":"CIDR (Subnet Mask)"},{"location":"04-helpers.html#inrange","text":"inRange(IpInterface $ip, int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP; $hostIp = IP::factory(':ffff:c22:384e'); $clientIp = IP::factory('12.48.183.1'); $clientIp->inRange($hostIp, 11); // bool(true) $clientIp->inRange($hostIp, 24); // bool(false)","title":"inRange()"},{"location":"04-helpers.html#getnetworkip","text":"getNetworkIp(int $cidr): IpInterface <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('12.34.56.78'); // Get the network address of an IP address given a subnet mask. $networkIp = $ip->getNetworkIp(19); $networkIp->getProtocolAppropriateAddress(); // string(\"12.34.32.0\") $ip === $networkIp; // bool(false)","title":"getNetworkIp()"},{"location":"04-helpers.html#getbroadcastip","text":"getBroadcastIp(int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('12.34.56.78'); // Get the broadcast address of an IP address given a subnet mask. $broadcastIp = $ip->getBroadcastIp(19); $broadcastIp->getProtocolAppropriateAddress(); // string(\"12.34.63.255\") $ip === $broadcastIp; // bool(false)","title":"getBroadcastIp()"},{"location":"05-strategies.html","text":"Embedding Strategies When using version 4 and version 6 addresses interchangeably (via the Multi class), version 4 addresses are embedded into version 6 addresses so that both versions are stored as 16-byte binary sequences. Unfortunately there are several different strategies for embedding a version 4 address into version 6, so this library offers various strategy implementations for the main three: Strategy Name Implementation Format 6to4-derived Darsyn\\IP\\Strategy\\Derived 2002:XXXX:XXXX:0000:0000:0000:0000:0000 IPv4-compatible Darsyn\\IP\\Strategy\\Compatible 0000:0000:0000:0000:0000:0000:XXXX:XXXX IPv4-mapped Darsyn\\IP\\Strategy\\Mapped 0000:0000:0000:0000:0000:ffff:XXXX:XXXX Each embedding strategy implements the EmbeddingStrategyInterface which defines methods to: detect whether a version 4 address is embedded into a version 6 address; extracting a version 4 address from a version 6 address; and packing a version 4 address into a version 6 address according to the given strategy. Specifying a Strategy This library will automatically use the IPv4-mapped embedding strategy unless otherwise instructed. An embedding strategy can be specified globally or on a per-instance basis. <?php use Darsyn\\IP\\Strategy; use Darsyn\\IP\\Version\\Multi as IP; // Set the IPv4-compatible embedding strategy to be used globally. IP::setDefaultEmbeddingStrategy(new Strategy\\Compatible); // But for this specific instance use the 6to4-derived embedding strategy. $ip = IP::factory('127.0.0.1', new Strategy\\Derived);","title":"Embedding Strategies"},{"location":"05-strategies.html#embedding-strategies","text":"When using version 4 and version 6 addresses interchangeably (via the Multi class), version 4 addresses are embedded into version 6 addresses so that both versions are stored as 16-byte binary sequences. Unfortunately there are several different strategies for embedding a version 4 address into version 6, so this library offers various strategy implementations for the main three: Strategy Name Implementation Format 6to4-derived Darsyn\\IP\\Strategy\\Derived 2002:XXXX:XXXX:0000:0000:0000:0000:0000 IPv4-compatible Darsyn\\IP\\Strategy\\Compatible 0000:0000:0000:0000:0000:0000:XXXX:XXXX IPv4-mapped Darsyn\\IP\\Strategy\\Mapped 0000:0000:0000:0000:0000:ffff:XXXX:XXXX Each embedding strategy implements the EmbeddingStrategyInterface which defines methods to: detect whether a version 4 address is embedded into a version 6 address; extracting a version 4 address from a version 6 address; and packing a version 4 address into a version 6 address according to the given strategy.","title":"Embedding Strategies"},{"location":"05-strategies.html#specifying-a-strategy","text":"This library will automatically use the IPv4-mapped embedding strategy unless otherwise instructed. An embedding strategy can be specified globally or on a per-instance basis. <?php use Darsyn\\IP\\Strategy; use Darsyn\\IP\\Version\\Multi as IP; // Set the IPv4-compatible embedding strategy to be used globally. IP::setDefaultEmbeddingStrategy(new Strategy\\Compatible); // But for this specific instance use the 6to4-derived embedding strategy. $ip = IP::factory('127.0.0.1', new Strategy\\Derived);","title":"Specifying a Strategy"},{"location":"06-formatters.html","text":"Formatters Internally, this library uses the PHP functions inet_pton and inet_ntop . However the inet_ntop function formats some IP addresses in an inconsistent and non-standard way (for example, the IP address ::ffff:c22:384e would be returned as ::ffff:12.34.56.78 when converting it's binary representation to human-readable protocol via inet_ntop ). This library provides a pure-PHP implementation called ConsistentFormatter to return IP addresses in the correct format, which is used by default. However should you wish to use the native implementation for any reason, you may set the NativeFormatter globally: <?php use Darsyn\\IP\\Formatter\\NativeFormatter; use Darsyn\\IP\\Version\\Multi as IP; IP::setProtocolFormatter(new NativeFormatter); $ip = IP::factory('::ffff:c22:384e'); $ip->getCompactedAddress(); // string(\"::ffff:12.34.56.78\")","title":"Formatters"},{"location":"06-formatters.html#formatters","text":"Internally, this library uses the PHP functions inet_pton and inet_ntop . However the inet_ntop function formats some IP addresses in an inconsistent and non-standard way (for example, the IP address ::ffff:c22:384e would be returned as ::ffff:12.34.56.78 when converting it's binary representation to human-readable protocol via inet_ntop ). This library provides a pure-PHP implementation called ConsistentFormatter to return IP addresses in the correct format, which is used by default. However should you wish to use the native implementation for any reason, you may set the NativeFormatter globally: <?php use Darsyn\\IP\\Formatter\\NativeFormatter; use Darsyn\\IP\\Version\\Multi as IP; IP::setProtocolFormatter(new NativeFormatter); $ip = IP::factory('::ffff:c22:384e'); $ip->getCompactedAddress(); // string(\"::ffff:12.34.56.78\")","title":"Formatters"},{"location":"07-types.html","text":"Type Methods The type methods return a boolean value depending on whether the IP address is a certain type. Mapped Whether the IP is an IPv4-mapped IPv6 address (eg, ::ffff:7f00:1 ) according to RFC 4291 . The IPV4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::ffff:7f00:1'); $ip->isMapped(); // bool(true) Derived Whether the IP is a 6to4-derived IPv6 address (eg, 2002:7f00:1:: ) according to RFC 3056 . The IPV4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('2002:7f00:1::'); $ip->isDerived(); // bool(true) Compatible Whether the IP is an IPv4-compatible IPv6 address (eg, ::7f00:1 ) according to RFC 4291 . The IPV4 class will always return bool(false) for this method. IPv4-compatible IPv6 addresses are deprecated in the RFC. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::7f00:1'); $ip->isCompatible(); // bool(true) Embedded Whether the IP is an IPv4-embedded IPv6 address (either a mapped or compatible address) according to RFC 4291 . The IPV4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::ffff:7f00:1'); $ip->isEmbedded(); // bool(true) Link Local Whether the IP is reserved for link-local usage according to RFC 3927 (IPv4) or RFC 4291 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isLinkLocal(); // bool(false) Loopback Whether the IP is a loopback address according to RFC 3330 (IPv4) or RFC 2373 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isLoopback(); // bool(true) Multicast Whether the IP is a multicast address according to RFC 3171 (IPv4) or RFC 2373 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isMulticast(); // bool(false) Private Use Whether the IP is for private use according to RFC 1918 (IPv4) or RFC 4193 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isPrivateUse(); // bool(false) Unspecified Whether the IP is unspecified according to RFC 5735 (IPv4) or RFC 2373 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isUnspecified(); // bool(false)","title":"Type Methods"},{"location":"07-types.html#type-methods","text":"The type methods return a boolean value depending on whether the IP address is a certain type.","title":"Type Methods"},{"location":"07-types.html#mapped","text":"Whether the IP is an IPv4-mapped IPv6 address (eg, ::ffff:7f00:1 ) according to RFC 4291 . The IPV4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::ffff:7f00:1'); $ip->isMapped(); // bool(true)","title":"Mapped"},{"location":"07-types.html#derived","text":"Whether the IP is a 6to4-derived IPv6 address (eg, 2002:7f00:1:: ) according to RFC 3056 . The IPV4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('2002:7f00:1::'); $ip->isDerived(); // bool(true)","title":"Derived"},{"location":"07-types.html#compatible","text":"Whether the IP is an IPv4-compatible IPv6 address (eg, ::7f00:1 ) according to RFC 4291 . The IPV4 class will always return bool(false) for this method. IPv4-compatible IPv6 addresses are deprecated in the RFC. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::7f00:1'); $ip->isCompatible(); // bool(true)","title":"Compatible"},{"location":"07-types.html#embedded","text":"Whether the IP is an IPv4-embedded IPv6 address (either a mapped or compatible address) according to RFC 4291 . The IPV4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('::ffff:7f00:1'); $ip->isEmbedded(); // bool(true)","title":"Embedded"},{"location":"07-types.html#link-local","text":"Whether the IP is reserved for link-local usage according to RFC 3927 (IPv4) or RFC 4291 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isLinkLocal(); // bool(false)","title":"Link Local"},{"location":"07-types.html#loopback","text":"Whether the IP is a loopback address according to RFC 3330 (IPv4) or RFC 2373 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isLoopback(); // bool(true)","title":"Loopback"},{"location":"07-types.html#multicast","text":"Whether the IP is a multicast address according to RFC 3171 (IPv4) or RFC 2373 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isMulticast(); // bool(false)","title":"Multicast"},{"location":"07-types.html#private-use","text":"Whether the IP is for private use according to RFC 1918 (IPv4) or RFC 4193 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isPrivateUse(); // bool(false)","title":"Private Use"},{"location":"07-types.html#unspecified","text":"Whether the IP is unspecified according to RFC 5735 (IPv4) or RFC 2373 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP; $ip = IP::factory('127.0.0.1'); $ip->isUnspecified(); // bool(false)","title":"Unspecified"},{"location":"08-doctrine.html","text":"Doctrine Support This library can be used to support IP address as column types with Doctrine. Three Doctrine types are provided to match the three version classes: IPV4Type supports IPv4 . IPV6Type supports IPv6 . MultiType supports Multi . <?php use Darsyn\\IP\\Doctrine\\MultiType; use Doctrine\\DBAL\\Types\\Type; Type::addType('ip', MultiType::class); If you are using Symfony , then add the following to your main configuration: doctrine: dbal: types: ip: Darsyn\\IP\\Doctrine\\MultiType Now you can happily store IP addresses in your entites like nobody's business: <?php use Darsyn\\IP\\Version\\Multi as IP; use Doctrine\\ORM\\Mapping as ORM; /** * @ORM\\Entity */ class AnalyticsEntity { /** * @ORM\\Column(type=\"ip\") */ protected $ipAddress; public function getIpAddress() { return $this->ipAddress; } public function setIpAddress(IP $ip) { $this->ipAddress = $ip; } }","title":"Doctrine Support"},{"location":"08-doctrine.html#doctrine-support","text":"This library can be used to support IP address as column types with Doctrine. Three Doctrine types are provided to match the three version classes: IPV4Type supports IPv4 . IPV6Type supports IPv6 . MultiType supports Multi . <?php use Darsyn\\IP\\Doctrine\\MultiType; use Doctrine\\DBAL\\Types\\Type; Type::addType('ip', MultiType::class); If you are using Symfony , then add the following to your main configuration: doctrine: dbal: types: ip: Darsyn\\IP\\Doctrine\\MultiType Now you can happily store IP addresses in your entites like nobody's business: <?php use Darsyn\\IP\\Version\\Multi as IP; use Doctrine\\ORM\\Mapping as ORM; /** * @ORM\\Entity */ class AnalyticsEntity { /** * @ORM\\Column(type=\"ip\") */ protected $ipAddress; public function getIpAddress() { return $this->ipAddress; } public function setIpAddress(IP $ip) { $this->ipAddress = $ip; } }","title":"Doctrine Support"},{"location":"09-param-converter.html","text":"Parameter Conversion If you are using Symfony's Framework Bundle, a parameter converter is included to automatically convert an IP string into an IP object. It's unlikely you'll ever need to get an IP address from the route instead of the Request object (aside from administration dashboards perhaps), but the option is there if you need it. To enabled it, make Darsyn\\IP\\ParamConverter a service in your container configuration and tag it with request.param_converter : services: darsyn.ip.param_converter: class: 'Darsyn\\IP\\ParamConverter' tags: - name: 'request.param_converter' converter: 'darsyn_ip_converter'","title":"Parameter Converter"},{"location":"09-param-converter.html#parameter-conversion","text":"If you are using Symfony's Framework Bundle, a parameter converter is included to automatically convert an IP string into an IP object. It's unlikely you'll ever need to get an IP address from the route instead of the Request object (aside from administration dashboards perhaps), but the option is there if you need it. To enabled it, make Darsyn\\IP\\ParamConverter a service in your container configuration and tag it with request.param_converter : services: darsyn.ip.param_converter: class: 'Darsyn\\IP\\ParamConverter' tags: - name: 'request.param_converter' converter: 'darsyn_ip_converter'","title":"Parameter Conversion"},{"location":"10-api.html","text":"API Reference Method Returns IPv4 IPv6 Multi factory(string $ip, [$strategy]) Static IpInterface \u2713 \u2713 \u2713 getBinary() string \u2713 \u2713 \u2713 getVersion() int \u2713 \u2713 \u2713 isVersion(int $version) bool \u2713 \u2713 \u2713 isVersion4() bool \u2713 \u2713 \u2713 isVersion6() bool \u2713 \u2713 \u2713 getNetworkIp(int $cidr): static Static IpInterface \u2713 \u2713 \u2713 getBroadcastIp(int $cidr): static Static IpInterface \u2713 \u2713 \u2713 inRange(IpInterface $ip, int $cidr) bool \u2713 \u2713 \u2713 isMapped() bool \u2713 \u2713 \u2713 isDerived() bool \u2713 \u2713 \u2713 isCompatible() bool \u2713 \u2713 \u2713 isEmbedded() bool \u2713 \u2713 \u2713 isLinkLocal() bool \u2713 \u2713 \u2713 isLoopback() bool \u2713 \u2713 \u2713 isMulticast() bool \u2713 \u2713 \u2713 isPrivateUse() bool \u2713 \u2713 \u2713 isUnspecified() bool \u2713 \u2713 \u2713 getDotAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getExpandedAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getProtocolAppropriateAddress() string \u2713","title":"API Reference"},{"location":"10-api.html#api-reference","text":"Method Returns IPv4 IPv6 Multi factory(string $ip, [$strategy]) Static IpInterface \u2713 \u2713 \u2713 getBinary() string \u2713 \u2713 \u2713 getVersion() int \u2713 \u2713 \u2713 isVersion(int $version) bool \u2713 \u2713 \u2713 isVersion4() bool \u2713 \u2713 \u2713 isVersion6() bool \u2713 \u2713 \u2713 getNetworkIp(int $cidr): static Static IpInterface \u2713 \u2713 \u2713 getBroadcastIp(int $cidr): static Static IpInterface \u2713 \u2713 \u2713 inRange(IpInterface $ip, int $cidr) bool \u2713 \u2713 \u2713 isMapped() bool \u2713 \u2713 \u2713 isDerived() bool \u2713 \u2713 \u2713 isCompatible() bool \u2713 \u2713 \u2713 isEmbedded() bool \u2713 \u2713 \u2713 isLinkLocal() bool \u2713 \u2713 \u2713 isLoopback() bool \u2713 \u2713 \u2713 isMulticast() bool \u2713 \u2713 \u2713 isPrivateUse() bool \u2713 \u2713 \u2713 isUnspecified() bool \u2713 \u2713 \u2713 getDotAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getExpandedAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getProtocolAppropriateAddress() string \u2713","title":"API Reference"}]}
